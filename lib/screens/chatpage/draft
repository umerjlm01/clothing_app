
import 'dart:async';
import 'dart:developer';
import 'dart:io';
import 'package:audioplayers/audioplayers.dart';
import 'package:clothing_app/bloc/bloc.dart';
import 'package:clothing_app/local_notifications/push_notification.dart';
import 'package:clothing_app/screens/chatpage/chat_models.dart';
import 'package:clothing_app/utils/constant_strings.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:flutter_native_contact_picker/flutter_native_contact_picker.dart';
import 'package:flutter_native_contact_picker/model/contact.dart';
import 'package:image_picker/image_picker.dart';
import 'package:open_filex/open_filex.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:rxdart/rxdart.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class ChatScreenBloc extends Bloc{

  final State<StatefulWidget> state;
  final BuildContext context;
  ChatScreenBloc(this.context, this.state, {required this.conversationId,required this.currentUserId,required this.receiverId}){
    initStream();
    scrollController.addListener(scrollListener);
  }

  final BehaviorSubject<List<ChatMessage>> _messagesStream = BehaviorSubject<List<ChatMessage>>.seeded([]);
  Stream<List<ChatMessage>> get messagesStream => _messagesStream.stream;
  final List<ChatMessage> _messages = [];
  StreamSubscription<List<Map<String,dynamic>>>? _messagesSub;
  final ValueNotifier<File?> _fileNotifier = ValueNotifier<File?>(null);
  ValueNotifier<File?> get fileNotifier => _fileNotifier;
  final ValueNotifier<Contact?> _contactNotifier = ValueNotifier<Contact?>(null);
  ValueNotifier<Contact?> get contactNotifier => _contactNotifier;

  final String conversationId;
  final String currentUserId;
  final String receiverId;
  final TextEditingController _messageController = TextEditingController();
  TextEditingController get messageController => _messageController;
  final ScrollController _scrollController = ScrollController();
  ScrollController get scrollController => _scrollController;

  final supabase = Supabase.instance.client;
  bool isLoading = false;
  bool hasMore = true;
  final int pageSize = 20;

  void initStream() async{
    try{
      await loadMoreMessages(isInitial: true);

      final response = supabase.from(ConstantStrings.messagesTable)
          .stream(primaryKey: ['id'])
          .eq('conversation_id', conversationId)
          .order('created_at', ascending: false)
          .limit(1);
      _messagesSub = response.listen((rows) {
        for (var row in rows) {
          final newMessage = ChatMessage.fromMap(row);

          // Prevent showing the same message twice (if pagination just fetched it)
          final alreadyExists = _messages.any((m) => m.id == newMessage.id);

          if (!alreadyExists) {
            // insert(0, ...) puts it at the bottom of your reversed ListView
            _messages.insert(0, newMessage);
            _messagesStream.add(List.from(_messages));
          }
        }
      });
      markMessagesAsRead();

    }
    catch(e,t){
      log('ChatBloc initStream error: $e\n$t');

    }
  }




  Future<void> sendMessage(File? imageFile) async {
    final text = _messageController.text.trim();
    final uid = supabase.auth.currentUser!.id;
    final selectedContact = _contactNotifier.value;
    final file = _fileNotifier.value;

    try {
      if (text.isEmpty && file == null && selectedContact == null) return;

      Map<String, dynamic> messagePayload;

      // 1️⃣ Contact
      if (selectedContact != null) {
        messagePayload = {
          'type': 'contact',
          'name': selectedContact.fullName,
          'phone': selectedContact.phoneNumbers
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
        };
      }
      // 2️⃣ File/Image/Document
      else if (file != null) {
        final ext = file.path.split('.').last.toLowerCase();
        final filename = '$uid/${DateTime.now().millisecondsSinceEpoch}_${file.path.split('/').last}';

        // Upload file
        await supabase.storage.from('chat-images').uploadBinary(
            filename, await file.readAsBytes());
        final url = supabase.storage.from('chat-images').getPublicUrl(filename);

        if (['png', 'jpg', 'jpeg', 'gif', 'heic', 'webp'].contains(ext)) {
          messagePayload = {
            'type': 'image',
            'url': url,
            'caption': text.isEmpty ? null : text,
            'filename': filename,
          };
        } else if(['pdf', 'doc', 'docx', 'xls', 'xlsx'].contains(ext)){
          // pdf, doc, docx, xls, xlsx, or unknown
          messagePayload = {
            'type': 'document',
            'url': url,
            'caption': text.isEmpty ? null : text,
            'filename': filename,

          };
        }else{
          messagePayload ={
            'type': 'audio',
            'url': url,
            'caption': text.isEmpty ? null : text,
            'filename': filename,
          };
        }
      }
      // 3️⃣ Text only
      else {
        messagePayload = {
          'type': 'text',
          'text': text,
        };
      }

      // Send message
      await supabase.from(ConstantStrings.messagesTable).insert({
        'conversation_id': conversationId,
        'sender_id': currentUserId,
        'created_at': DateTime.now().toIso8601String(),
        'is_read': false,
        'text': messagePayload,
      });

      // Clear inputs
      _messageController.clear();
      _fileNotifier.value = null;
      _contactNotifier.value = null;
      scrollToBottom();

      // Determine last message
      String lastMessage;
      if (selectedContact != null) {
        lastMessage =
        '${selectedContact.fullName} - ${selectedContact.phoneNumbers.toString().replaceAll('[', '').replaceAll(']', '')}';
      } else if (file != null) {
        final ext = file.path.split('.').last.toLowerCase();
        lastMessage = ['png', 'jpg', 'jpeg', 'gif', 'heic', 'webp']
            .contains(ext)
            ? 'Image sent'
            : 'Document: ${file.path.split('/').last}';
      } else {
        lastMessage = text.trim();
      }

      // Update conversation
      await supabase.from(ConstantStrings.conversationsTable).update({
        'last_message': lastMessage,
        'last_message_at': DateTime.now().toIso8601String(),
      }).eq('id', conversationId);

      // Trigger push notification
      await PushNotificationService.instance.trigger(
        receiverId: receiverId,
        title: 'New Message',
        body: lastMessage,
        conversationId: conversationId,
      );

      log('Message sent successfully');
    } catch (e, t) {
      log('ChatBloc sendMessage error: $e\n$t');
    }
  }

  Future<void> markMessagesAsRead() async {
    try {
      if(currentUserId == receiverId) return;
      if(currentUserId != receiverId){
      await supabase.from(ConstantStrings.messagesTable).
      update({'is_read': true})
          .eq('conversation_id', conversationId)
          .neq('sender_id', currentUserId)
          .eq('is_read', false);
    }}
  catch(e,t){
      log('ChatBloc markMessagesAsRead error: $e\n$t');

  }
  }


  /// Pagination

  Future<void> loadMoreMessages({bool isInitial = false}) async{
    if(isLoading || (!hasMore && !isInitial)) return;
    isLoading = true;
    try{
      var loadMessages = supabase.from(ConstantStrings.messagesTable).select()
          .eq('conversation_id', conversationId);

      if(!isInitial && _messages.isNotEmpty){
        final oldestTimestamp = _messages.last.createdAt; // Use the timestamp from your model
        log('DEBUG: Fetching older than $oldestTimestamp');
        loadMessages = loadMessages.lt('created_at', oldestTimestamp.toString());
      }

      final response = await loadMessages.order('created_at', ascending: false).limit(pageSize);
      log('response: ${response.length}');

      if(response.isEmpty) {
        log('No more messages to fetch');
        hasMore = false;
        return;
      }
      final newMessages = response.map((e) => ChatMessage.fromMap(e)).toList();

// Filter out any messages that are already in the list
      final uniqueNewMessages = newMessages.where((newMsg) =>
      !_messages.any((existingMsg) => existingMsg.id == newMsg.id)
      ).toList();

      if (uniqueNewMessages.isEmpty) {
        // If we got data but it's all duplicates, we should stop trying to load more
        hasMore = false;
      } else{
        _messages.addAll(uniqueNewMessages);
        if(newMessages.length < pageSize) hasMore = false;
      }

    }
    catch (e,t){
      log('ChatBloc loadMoreMessages error: $e\n$t');
    }
    finally{
      isLoading = false;
      _messagesStream.add(List.from(_messages));

    }
  }
  void scrollListener() {
    try{
      if(isLoading || !hasMore) return;
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 100) {
      log('Scroll listener is fetching more');
      loadMoreMessages();
  }}
  catch(e){
      log('ChatBloc scrollListener error: $e');
  }
  }

  void scrollToBottom(){
    if(_scrollController.hasClients) {
      scrollController.animateTo(0, duration: const Duration(milliseconds: 300), curve: Curves.easeOut);
    }
  }


  /// Bottom Sheet///

  final ImagePicker _imagePicker = ImagePicker();
  Future<void> pickImage() async{
    try{
      final pickedFile = await _imagePicker.pickImage(source: ImageSource.gallery);
      if(pickedFile != null){
        _fileNotifier.value = File(pickedFile.path);
        log('Image selected: ${_fileNotifier.value!.path}');
      }
        else{
          _fileNotifier.value = null;
          log('No image selected');
        }

    }
    catch (e,t){
      log('ChatBloc _pickImage error: $e \n $t');
    }
  }

  Future<void> pickImageFromCamera() async{
    try{
     final pickedFileFromCamera = await _imagePicker.pickImage(source: ImageSource.camera);
     if(pickedFileFromCamera != null){
       _fileNotifier.value = File(pickedFileFromCamera.path);
       log('Image selected: ${_fileNotifier.value!.path}');
     }
     else{
       _fileNotifier.value = null;
       log('No image selected');
     }

  }
  catch(e,t){
      log('ChatBloc _pickImageFromCamera error: $e \n $t');
  }
  }

  Future<void> pickContacts() async{
   try{
     final FlutterNativeContactPicker contactPicker = FlutterNativeContactPicker();
     final status = await Permission.contacts.request();
     if(status == PermissionStatus.granted){
       final selected = await contactPicker.selectContact();
       if(selected != null){
         _contactNotifier.value = selected;
         _fileNotifier.value = null;
         log('Contact selected: ${_contactNotifier.value!.fullName}');
       }
       else{
         _contactNotifier.value = null;
         log('No contact selected');
       }
     }
     else{
       log('Permission denied');
     }
    sendMessage(null);
     _contactNotifier.value = null;
   }
   catch(e,t){
     log('ChatBloc _pickContacts error: $e \n $t');
   }
  }

  Future<void> pickDocument() async{
    try{
    final result = await FilePicker.platform.pickFiles(
    type: FileType.any);

    if(result !=null && result.files.isNotEmpty){
    _fileNotifier.value = File(result.files.first.path!);
    log('Document selected: ${_fileNotifier.value!.path}');
    }
    else{
    _fileNotifier.value = null;
    log('No document selected');
    }
    sendMessage(null);
    _fileNotifier.value= null;

    }
    catch(e,t){
      log('ChatBloc _pickDocument error: $e \n $t');
    }

  }

  Future<void> pickAudio()async {
    try {
      final result = await FilePicker.platform.pickFiles(
          type: FileType.audio);
      if(result != null && result.files.isNotEmpty) {
        _fileNotifier.value = File(result.files.first.path!);
        log('Audio selected: ${_fileNotifier.value!.path}');
      }
      else {
        _fileNotifier.value = null;
        log('No audio selected');
      }
     sendMessage(null);
      _fileNotifier.value = null;

    }
    catch(e,t){
      log('ChatBloc _pickAudio error: $e \n $t');
    }

  }
  final AudioPlayer audioPlayer = AudioPlayer();

  final ValueNotifier<AudioState> audioStateNotifier =
  ValueNotifier(AudioState(isPlaying: false, currentlyPlayingPath: null));

  Future<void> playAudio(ChatMessage msg) async {
    try {
      final filename = msg.filename;
      if (filename == null) return;

      // Get public URL
      final url = supabase.storage.from('chat-images').getPublicUrl(filename);

      final currentState = audioStateNotifier.value;

      // If currently playing this audio, pause it
      if (currentState.isPlaying && currentState.currentlyPlayingPath == filename) {
        await audioPlayer.pause();
        audioStateNotifier.value = AudioState(isPlaying: false, currentlyPlayingPath: null);
      }
      // Otherwise, play this audio
      else {
        await audioPlayer.play(UrlSource(url));
        audioStateNotifier.value = AudioState(isPlaying: true, currentlyPlayingPath: filename);
      }

    } catch (e, t) {
      log('ChatBloc playAudio error: $e \n $t');
    }
  }






  Future<void> downloadFile(ChatMessage msg) async {
    try {
      final storagePath = msg.filename;
      if(storagePath == null) return;

      //)
      // 1. Download bytes from Supabase
      final bytes = await supabase.storage.from('chat-images').download(storagePath);

      // 2. Get correct directory
      final dir = await getApplicationDocumentsDirectory();
      // 3. Use the message's filename to ensure consistency
      final name = storagePath.split('/').last;
      // '
      final savePath = '${dir.path}/$name';
      final savedFile =File(savePath);
      // 4. Write the file
      await savedFile.writeAsBytes(bytes);
      log('File downloaded to: $savePath');
     if(await savedFile.exists()) {
       return openFile(savePath);
     }
      // 5. Open the file properly
     await openFile(savePath);


      // 6. Trigger Notification
      PushNotificationService.instance.trigger(
          receiverId: currentUserId,
          title: 'File Downloaded',
          body: 'Tap to open ${msg.filename}',
          conversationId: conversationId,
      );
    } catch (e, t) {
      log('ChatBloc downloadFile error: $e \n $t');
    }
  }
  Future<void> openFile(String filePath) async {
    try {
      // Check if file exists first
      final file = File(filePath);
      if (await file.exists()) {
        // Use open_filex package
        await OpenFilex.open(filePath);
      } else {
        log("Cannot open file: File does not exist at $filePath");
      }
    } catch (e, t) {
      log('ChatBloc _openFile error: $e \n $t');
    }
  }










  @override
  void dispose() {
    _messagesSub?.cancel();
    _messagesStream.close();
    _messageController.dispose();
    _scrollController.dispose();
    // TODO: implement dispose
  }

}

class AudioState {
  final bool isPlaying;
  final String? currentlyPlayingPath;

  AudioState({required this.isPlaying, this.currentlyPlayingPath});
}
